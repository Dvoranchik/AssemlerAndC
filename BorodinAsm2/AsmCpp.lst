Microsoft (R) Macro Assembler Version 14.00.24245.0	    04/21/20 11:22:27
Dec2Str.asm						     Page 1 - 1


				.686
				.MODEL FLAT, C
				.STACK
 00000000			.DATA
				;-----------Local data------------------------------
 00000000			.CODE
				include DigLen.inc
			      C 
			      C ;
			      C ; Макрос проверяет длину числа, содержащегося в EAX
			      C ;
			      C ; Вход:
			      C ;		EAX – число, для которого подсчитывается длина
			      C ; Выход:
			      C ;		BX – длина числа содержащегося в EAX
			      C ;
			      C DigitLen MACRO
			      C 	mov 	esi, 10 ; счетчик чисел
			      C 	l = 1000000000 ; маска с которой будем сравнивать
			      C 	REPT 9  ;цикл 9 раз повторяющий операцию
			      C 		cmp eax, l  ; сравниваем число с маской
			      C 		sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
			      C 		l = l / 10 ;уменьшаем маску на 10
			      C 	ENDM
			      C ENDM DigitLen
			      C 
					; Перевод числа в строковое представление и дальнейшая запись его в ; буфер
					;
					; Вход: 
					; 		EAX – число для перевода в строку
					;		
					;Выход:
					;		EDX - 0 или 1 в зависимости от знака
					;
 00000000			IntToStr proc C num:dword, flag:dword, arr:dword, n:dword, last:dword
 00000003  8B 45 08			mov eax, num
 00000006  8B 5D 0C			mov ebx, flag
 00000009  8B 7D 10			mov edi, arr
 0000000C  8B 4D 14			mov ecx, n
 0000000F  51				push	ecx
 00000010			@@signIs:
 00000010  50				push eax ;сохраняем число
 00000011  C1 E8 1F			shr eax, 31;побитово сдвигаем до 1го бита
 00000014  83 F8 00			cmp eax, 0; проверяем 1 бит
 00000017  74 0A			jz @@plus;если положительное
 00000019  58				pop eax;возращаем число
 0000001A  F7 D8			neg eax;переводим из отрицательного
 0000001C  BA 00000001			mov edx, 1;флаг знака
 00000021  EB 06			jmp @@flag
 00000023			@@plus:
 00000023  58				pop eax
 00000024  BA 00000000			mov edx, 0
 00000029			@@flag:
 00000029  52				push edx
					DigitLen ;определяем длину числа
 0000002A  BE 0000000A	     1		mov 	esi, 10 ; счетчик чисел
 0000002F  3D 3B9ACA00	     2			cmp eax, l  ; сравниваем число с маской
 00000034  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 00000037  3D 05F5E100	     2			cmp eax, l  ; сравниваем число с маской
 0000003C  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 0000003F  3D 00989680	     2			cmp eax, l  ; сравниваем число с маской
 00000044  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 00000047  3D 000F4240	     2			cmp eax, l  ; сравниваем число с маской
 0000004C  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 0000004F  3D 000186A0	     2			cmp eax, l  ; сравниваем число с маской
 00000054  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 00000057  3D 00002710	     2			cmp eax, l  ; сравниваем число с маской
 0000005C  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 0000005F  3D 000003E8	     2			cmp eax, l  ; сравниваем число с маской
 00000064  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 00000067  83 F8 64	     2			cmp eax, l  ; сравниваем число с маской
 0000006A  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 0000006D  83 F8 0A	     2			cmp eax, l  ; сравниваем число с маской
 00000070  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 00000073  83 FE 0A			cmp esi, 10
 00000076  0F 87 000000B1		ja @@invalid_arg
 0000007C  83 FF 00			cmp edi, 0
 0000007F  0F 84 000000A8		jz @@invalid_arg
					;
					; В зависимости от типа выравнивания, вычисляет 
					; размер буфера для записываемого числа
					;
					; Вход: 
					;	     BL = 0 / не ноль (В зависимости от типа 
					; 		выравнивания)
					;	     EAX – исходное число для перевода в строку
					;	     EDX = 0 / -1 (В зависимости от знака числа в EAX) 
					; Выход:
					;	     ESI – длина числа в виде строки с учетом знака
					;
 00000085			@@len_checking:
 00000085  80 FB 00			cmp     bl, 0   ;проверяем тип выравнивания
 00000088  75 53			jnz @@right_align   ;не 0 - правое
					DigitLen ;определяем длину числа
 0000008A  BE 0000000A	     1		mov 	esi, 10 ; счетчик чисел
 0000008F  3D 3B9ACA00	     2			cmp eax, l  ; сравниваем число с маской
 00000094  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 00000097  3D 05F5E100	     2			cmp eax, l  ; сравниваем число с маской
 0000009C  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 0000009F  3D 00989680	     2			cmp eax, l  ; сравниваем число с маской
 000000A4  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000A7  3D 000F4240	     2			cmp eax, l  ; сравниваем число с маской
 000000AC  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000AF  3D 000186A0	     2			cmp eax, l  ; сравниваем число с маской
 000000B4  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000B7  3D 00002710	     2			cmp eax, l  ; сравниваем число с маской
 000000BC  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000BF  3D 000003E8	     2			cmp eax, l  ; сравниваем число с маской
 000000C4  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000C7  83 F8 64	     2			cmp eax, l  ; сравниваем число с маской
 000000CA  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000CD  83 F8 0A	     2			cmp eax, l  ; сравниваем число с маской
 000000D0  83 DE 00	     2			sbb esi, 0 ; вычитаем из счетчика 1 или 0 в зависимости от значения сравнения
 000000D3  83 FA 00			cmp edx, 0
 000000D6  75 0A			jnz @@buffer_check
 000000D8  4E				dec esi
 000000D9  03 F3			add esi, ebx ; записываем в esi длину
 000000DB  EB 05			jmp @@buffer_check
 000000DD			@@right_align:
 000000DD  BE 0000000B			mov  esi, 11 ; необходимый размер = 11
					;
					; Проверяет корректность размера буфера
					;
					; Вход: 
					; 		ECX – размер буфера
					;		ESI – длина записываемого числа с учетом знака
					; Выход:
					;		Ошибка / успешное продолжение
					;
 000000E2			@@buffer_check:
 000000E2  53				push ebx
 000000E3  BB 0000000A			mov ebx, 10d ;делитель для числа
 000000E8  3B CE			cmp ecx, esi ;проверяем достаточно ли места 
 000000EA  72 38			jb  @@error_message
					;
					; Перевод числа в строковое представление и дальнейшая запись его в ; буфер
					;
					; Вход: 
					; 		EAX – число для перевода в строку
					;		EDI – буфер для записи числа
					;		ESI – длина записываемого числа с учетом знака
					; Выход:
					;		EDI - буфер для записи числа
					;
 000000EC			@@get_digits:
 000000EC  33 D2			xor     edx, edx    ;обнуляем edx
 000000EE  F7 F3			div     ebx ;делим на длину слова
 000000F0  80 CA 30			or  dl, 30h     ; остаток в букву
 000000F3  26: 88 14 3E			mov     es:[edi+esi], dl ;записываем букву
 000000F7  4E				dec     esi ;уменьщаем счетчик 
 000000F8  83 F8 00			cmp     eax, 0      ;если закончили то в пустые места - пробелы
 000000FB  74 02			jz  @@minus
 000000FD  E2 ED			loop @@get_digits
 000000FF			@@minus:
 000000FF  5B				pop ebx;возвращаем edx
 00000100  5A				pop edx;возвращаем флаг
 00000101  83 FA 00			cmp edx, 0
 00000104  74 09			jz @@spacing;если не отрицательное
 00000106  B0 2D			mov     al, 2Dh;если да ставим минус
 00000108  26: 88 04 3E			mov     es:[edi + esi], al
 0000010C  4E				dec     esi;уменьщаем счетчик
 0000010D  B0 20			mov     al, 20h ; записываем пробел
 0000010F			@@spacing:
 0000010F  83 FE 00			cmp  esi, 0     ;проверяем отрицательно ли число
 00000112  72 09			jb  @@GoodAndLoop ;переход если да, то выходим
 00000114  26: 88 04 3E			mov     es:[edi + esi], al ;записываем в строку
 00000118  4E				dec     esi ;уменьшаем счетчик
 00000119  B0 20			mov     al, 20h ; записываем пробел
 0000011B  E2 F2			loop     @@spacing
 0000011D			@@GoodAndLoop:
 0000011D  B8 00000000			mov eax, 0
 00000122  EB 0F			jmp @@EndLoop
 00000124			@@error_message:
 00000124  5A				pop edx
 00000125  5B				pop ebx
 00000126  B8 8007000E			mov eax, 8007000Eh;флаг ошибки
 0000012B  EB 06			jmp @@EndLoop
 0000012D			@@invalid_arg:
 0000012D  5A				pop edx
 0000012E  B8 80070057			mov eax, 80070057h;флаг ошибки
 00000133			@@EndLoop:
 00000133  59				pop ecx
 00000134			@@EndProc:
					ret
 00000136			IntToStr endp
Dec2Str.asm(128) : warning A6004:procedure argument or local not referenced : last
				END
Microsoft (R) Macro Assembler Version 14.00.24245.0	    04/21/20 11:22:27
Dec2Str.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

DigitLen . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000400 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000000 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000136 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

IntToStr . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000136 Public C
  num  . . . . . . . . . . . . .	DWord	 bp + 00000008
  flag . . . . . . . . . . . . .	DWord	 bp + 0000000C
  arr  . . . . . . . . . . . . .	DWord	 bp + 00000010
  n  . . . . . . . . . . . . . .	DWord	 bp + 00000014
  last . . . . . . . . . . . . .	DWord	 bp + 00000018
  @@signIs . . . . . . . . . . .	L Near	 00000010 _TEXT	
  @@plus . . . . . . . . . . . .	L Near	 00000023 _TEXT	
  @@flag . . . . . . . . . . . .	L Near	 00000029 _TEXT	
  @@len_checking . . . . . . . .	L Near	 00000085 _TEXT	
  @@right_align  . . . . . . . .	L Near	 000000DD _TEXT	
  @@buffer_check . . . . . . . .	L Near	 000000E2 _TEXT	
  @@get_digits . . . . . . . . .	L Near	 000000EC _TEXT	
  @@minus  . . . . . . . . . . .	L Near	 000000FF _TEXT	
  @@spacing  . . . . . . . . . .	L Near	 0000010F _TEXT	
  @@GoodAndLoop  . . . . . . . .	L Near	 0000011D _TEXT	
  @@error_message  . . . . . . .	L Near	 00000124 _TEXT	
  @@invalid_arg  . . . . . . . .	L Near	 0000012D _TEXT	
  @@EndLoop  . . . . . . . . . .	L Near	 00000133 _TEXT	
  @@EndProc  . . . . . . . . . .	L Near	 00000134 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000001h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
l  . . . . . . . . . . . . . . .	Number	 00000001h   

	   1 Warnings
	   0 Errors
